fullnameOverride: "jupyterhub"
nameOverride:

enabled: true

debug:
  enabled: true

hub:
  config:
    # Authenticator:
    #   admin_users:
    #   - jesmigel
    JupyterHub:
      allow_named_servers: true
      # admin_users:
      #   - jesmigel
      #   - admin
      authenticator_class: generic-oauth

    # GenericOAuthenticator:
    #   token_url: "https://auth.jcan.dev/application/o/token/"
    #   authorize_url: "https://auth.jcan.dev/application/o/authorize/"
    #   userdata_url: "https://auth.jcan.dev/application/o/userinfo/"
    #   scope:
    #     - openid
    #     - email
    #     - profile
    #   login_service: "Authentik"
    #   username_key: "preferred_username"
    #   userdata_params: {"state": "state"}

  extraConfig:
    00-authentik.py: |
      import os
      from oauthenticator.generic import GenericOAuthenticator
      from tornado import gen

      # Dynamically map Authentik groups to JupyterHub roles
      class GroupMappingAuthenticator(GenericOAuthenticator):
          @gen.coroutine
          def pre_spawn_start(self, user, spawner):
              auth_state = yield user.get_auth_state()
              if not auth_state:
                  return
              groups = auth_state.get("groups", [])
              spawner.log.info("%s groups: %s", user.name, groups)

              # Promote users in "JupyterHub Admins" group to admin
              if "JupyterHub Admins" in groups:
                  user.admin = True

              # Optionally, you could restrict spawn to members of "JupyterHub Users" only
              if "JupyterHub Users" not in groups:
                  raise Exception("Not authorized to spawn")

      # Set the authenticator class
      c.JupyterHub.authenticator_class = GroupMappingAuthenticator

      c.GenericOAuthenticator.client_id = os.environ["OAUTH_CLIENT_ID"]
      c.GenericOAuthenticator.client_secret = os.environ["OAUTH_CLIENT_SECRET"]
      c.GenericOAuthenticator.token_url = "https://auth.jcan.dev/application/o/token/"
      c.GenericOAuthenticator.authorize_url = "https://auth.jcan.dev/application/o/authorize/"
      c.GenericOAuthenticator.userdata_url = "https://auth.jcan.dev/application/o/userinfo/"
      c.GenericOAuthenticator.userdata_params = {"state": "state"}
      c.GenericOAuthenticator.scope = ["openid", "email", "profile"]
      c.GenericOAuthenticator.login_service = "Authentik"
      c.GenericOAuthenticator.username_key = "preferred_username"

      # allow all Authentik users
      c.Authenticator.whitelist = set()

    # authenticator_class: gitlab
    # GitLabOAuthenticator:
    #   # the following are obtained from OS env vars
    #   # - https://github.com/jupyterhub/oauthenticator/blob/main/oauthenticator/gitlab.py
    #   # client_id: env:OAUTH_CLIENT_ID
    #   # client_secret: env:OAUTH_CLIENT_SECRET
    #   # oauth_callback_url: env:OAUTH_CALLBACK_URL
    #   gitlab_url: https://gitlab.com
    #   scope:
    #     - "read_api"
    #     - "read_user"
    #     - "openid"
    #     - "profile"
    #     - "email"
    #   username_key: username
    #   gitlab_group_whitelist: ["Kube-Mind"]
    #   gitlab_project_id_whitelist: []

  # extraConfig:
  #   gitlab: |
  #     c.KubeSpawner.cmd = ['jupyter-labhub']
  #     async def pre_spawn_hook(spawner):
  #       auth_state = await spawner.user.get_auth_state()
  #       if not auth_state:
  #           spawner.log.warning("No auth state for %s", spawner.user)
  #           return
  #       spawner.environment['GITLAB_ACCESS_TOKEN'] = auth_state['access_token']
  #       spawner.environment['GITLAB_USER_LOGIN'] = auth_state['gitlab_user']['username']
  #       spawner.environment['GITLAB_USER_ID'] = str(auth_state['gitlab_user']['id'])
  #       spawner.environment['GITLAB_USER_EMAIL'] = auth_state['gitlab_user']['email']
  #       spawner.environment['GITLAB_USER_NAME'] = auth_state['gitlab_user']['name']
  #     c.KubeSpawner.pre_spawn_hook = pre_spawn_hook

  extraEnv:
    OAUTH_CALLBACK_URL: "https://jhub.jcan.dev/hub/oauth_callback"
    GITLAB_HOST: https://gitlab.com
    OAUTH_CLIENT_ID:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-external-secret
          key: JUPYTERHUB_CLIENT_ID
          # key: GITLAB_APPLICATION_ID
    OAUTH_CLIENT_SECRET:
      valueFrom:
        secretKeyRef:
          name: jupyterhub-external-secret
          key: JUPYTERHUB_CLIENT_SECRET
          # key: GITLAB_CLIENT_SECRET
    # OAUTH_CALLBACK_URL:
    #   valueFrom:
    #     secretKeyRef:
    #       name: jupyterhub-external-secret
    #       key: GITLAB_CALLBACK_URL

  networkPolicy:
    egress:
      - ports:
          - port: 6443

  service:
    type: ClusterIP

singleuser:
  startTimeout: 3600
  image:
    name: quay.io/jupyterhub/k8s-singleuser-sample
  # extraNodeAffinity:
  #   required:
  #     - matchExpressions:
  #       - key: kubernetes.io/hostname
  #         operator: In
  #         values:
  #           - turing
  memory:
    guarantee: 2G
    limit: 2G
  cpu:
    guarantee: 2
    limit: 2
  profileList:
    - display_name: "Default: Shared, 2 CPU cores and 2GB RAM"
      description: "By selecting this choice, you will be assigned a environment that will run on a shared machine with CPU only."
      default: True
    - display_name: "Dedicated, 2 CPU cores & 4GB RAM, 1 Random NVIDIA GPU"
      description: "By selecting this choice, you will be assigned a environment that will run on a dedicated machine with a single GPU, just for you."
      kubespawner_override:
        # image: consideratio/singleuser-gpu:v0.3.0
        extra_pod_config:
          runtimeClassName: nvidia
        extra_resource_limits:
          nvidia.com/gpu: "1"
        mem_limit: 4G
    - display_name: "Dedicated, 2 CPU cores & 4GB RAM, 1 NVIDIA RTX 4000 Ada generation GPU"
      description: "By selecting this choice, you will be assigned a environment that will run on a dedicated machine with a single NVIDIA RTX 4000 Ada GPU, just for you."
      kubespawner_override:
        # image: consideratio/singleuser-gpu:v0.3.0
        extra_pod_config:
          runtimeClassName: nvidia
        # extra_resource_limits:
        #   nvidia.com/gpu: "1"
        mem_limit: 4G
        node_affinity_required:
          required:
            - matchExpressions:
              - key: kubernetes.io/hostname
                operator: In
                values:
                  - turing
  storage:
    type: dynamic
    dynamic:
      storageClass: longhorn

scheduling:
  userScheduler:
    enabled: true
    revisionHistoryLimit:
    replicas: 2
    logLevel: 5

ingress:
  enabled: true
  ingressClassName: traefik
  annotations:
    traefik.ingress.kubernetes.io/router.entrypoints: websecure
    traefik.ingress.kubernetes.io/router.tls: "true"
    cert-manager.io/cluster-issuer: letsencrypt-prd
  hosts:
    - jhub.jcan.dev

  tls:
    - hosts:
        - jhub.jcan.dev
      secretName: jupyterhub-tls

prePuller:
  hook:
    enabled: true
  continuous:
    enabled: true
